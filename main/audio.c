#include "driver/gpio.h"		
#include "driver/i2s_std.h"	
#include "esp_log.h"
#include "esp_pm.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "soc/rtc.h"
#include <dirent.h>
#include <pthread.h>
#include <string.h>

#include "es8388.h"

#include "helix.h"

smartControl *cdAudioBuffer;

int playCDEnable = 0;

//i2s_chan_handle_t rx_handle;
i2s_chan_handle_t tx_handle;

void audioInit(void) {

	if (!cdAudioBuffer)
		cdAudioBuffer = createSmartBuffer (50000);

  int rate = 44100;

  //  printf("About to call es8388_init\n");
  es8388_init(rate);
  //  printf("es8388_init done\n");

  int initialGain = 10;

  es8388_set_adc_gain(initialGain);
  //  printf("Initial gain set to %d\n", initialGain);
 

  /******************* This is the new v5.0 I2S system */  
  
  

/* Get the default channel configuration by helper macro.
 * This helper macro is defined in 'i2s_common.h' and shared by all the i2s communication mode.
 * It can help to specify the I2S role, and port id */
i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
/* Allocate a new tx channel and get the handle of this channel */
i2s_new_channel(&chan_cfg, &tx_handle, NULL);

/* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
 * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
 * They can help to specify the slot and clock configurations for initialization or updating */
i2s_std_config_t std_cfg = {
    .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(44100),
    .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
    .gpio_cfg = {
        .mclk = I2S_GPIO_UNUSED,
        .bclk = GPIO_NUM_38,
        .ws = GPIO_NUM_17,
        .dout = GPIO_NUM_18,
        .din = GPIO_NUM_7,
        .invert_flags = {
            .mclk_inv = false,
            .bclk_inv = false,
            .ws_inv = false,
        },
    },
};
/* Initialize the channel */
i2s_channel_init_std_mode(tx_handle, &std_cfg);

/* Before read data, start the tx channel first */
i2s_channel_enable(tx_handle);  
  
 #if 0   
  
  vTaskDelay(1000 / portTICK_PERIOD_MS);

  //************************** Use external crystal

#if 0
	setupDivider (rate);
#endif

  //****************************

  // Disable CLK_OUT2 from RXD pin

  gpio_set_direction(44, GPIO_MODE_INPUT);

  setPeripheralInput(
      12, 44); // RXD0 from GPIO44 - pages 207 & 230 technical reference manual

#endif

}

pthread_t audioThread;

#define AUDIOBUFFERSIZE 2048
int16_t audioBuffer[AUDIOBUFFERSIZE];

void *audioThreadCode(void *param) {

	int n;
	int16_t *s = audioBuffer;
	int16_t v = 0;
	
	for (n=0;n<AUDIOBUFFERSIZE;n++){
		*s++ = v;
		v += 1;
	}	


  while (true) {

    int n;
    size_t len;

//    i2s_channel_read(rx_handle, audioBuffer, AUDIOBUFFERSIZE, &len, 100 / portTICK_PERIOD_MS);

	n = smartGetSamplesS (cdAudioBuffer, AUDIOBUFFERSIZE/2, audioBuffer);
	if (!n) bzero (audioBuffer,AUDIOBUFFERSIZE*2);

	int count = AUDIOBUFFERSIZE*2;
	while (count){
		i2s_channel_write(tx_handle, audioBuffer, AUDIOBUFFERSIZE*2, &len, 100 / portTICK_PERIOD_MS);
		count -= len;
	}	


  }
}

void startAudioThread() {

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, THREADSTACKSIZE);

  pthread_create(&audioThread, &attr, &audioThreadCode, 0);
}

pthread_t cdThread;

int playCDSector;

void *cdThreadCode(void *param) {

	s16 *data;
	while (1){
		if (playCDEnable){
			readBlocks (playCDSector,1);
			playCDSector += BLOCKSIZE;
			data = (s16 *) getDataAddress ();
			smartPutSamplesW (cdAudioBuffer, (2352*BLOCKSIZE)/4, data);
		}
		else delay (1000);
	}	

}

void startCDThread() {

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, THREADSTACKSIZE);

  pthread_create(&cdThread, &attr, &cdThreadCode, 0);
}



void startPlayingCD (int lba){
	playCDSector = lba;
	playCDEnable = 1;	
}	

void stopPlayingCD (){
	playCDEnable = 0;
}	


