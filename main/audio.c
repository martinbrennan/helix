#include "driver/gpio.h"		
#include "driver/i2s_std.h"	
#include "esp_log.h"
#include "esp_pm.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "soc/rtc.h"
#include <dirent.h>
#include <pthread.h>
#include <string.h>

#include "es8388.h"
#include "math.h"

#include "helix.h"

smartControl *cdAudioBuffer;

int playCDEnable = 0;

//i2s_chan_handle_t rx_handle;
i2s_chan_handle_t tx_handle;


// base addresses p131 S3 Technical Reference Manual

#define I2S0BASE 0x6000F000
#define I2S1BASE 0x6002D000
#define GPIOBASE 0x60004000
#define IOMUXBASE 0x60009000
#define mI2S_RX_CONF_REG 0x20
#define mI2S_RX_CONF1_REG 0x28
#define mI2S_TX_CONF1_REG 0x2c
#define mI2S_RX_CLKM_CONF_REG 0x30
#define mI2S_TX_CLKM_CONF_REG 0x34
#define mI2S_RX_CLKM_DIV_CONF_REG 0x38
#define mI2S_TX_CLKM_DIV_CONF_REG 0x3C

#define mGPIO_ENABLE_REG 0x20
#define mGPIO_W1TS_REG 0x24
#define mGPIO_ENABLE_W1TS_REG 0x24

uint32_t readReg(uint32_t base, uint32_t offset) {
  uint32_t r = *(volatile uint32_t *)(base + offset);
  return r;
}

void writeReg(uint32_t base, uint32_t offset, uint32_t value) {
  volatile uint32_t *a = (volatile uint32_t *)(base + offset);
  *a = value;
}

// table of peripherals p206 S3 Technical Reference Manual

void setPeripheralOutput(unsigned peripheral, unsigned gpio) {
  uint32_t ai = (GPIOBASE + 0x0554 + (4 * gpio));
  volatile uint32_t *a = (volatile uint32_t *)ai;
  *a = peripheral + 0x400;
}

uint32_t readPeripheralOutput(unsigned gpio) {
  uint32_t ai = (GPIOBASE + 0x0554 + (4 * gpio));
  volatile uint32_t *a = (volatile uint32_t *)ai;
  return *a;
}

void setPeripheralInput(unsigned peripheral, unsigned gpio) {
  uint32_t ai = (GPIOBASE + 0x0154 + (4 * peripheral));
  volatile uint32_t *a = (volatile uint32_t *)ai;
  *a = gpio + 0x80;
}

uint32_t readPeripheralInput(unsigned peripheral) {
  uint32_t ai = (GPIOBASE + 0x0154 + (4 * peripheral));
  volatile uint32_t *a = (volatile uint32_t *)ai;
  return *a;
}

uint32_t readIOMux(unsigned gpio) {
  uint32_t ai = (IOMUXBASE + 0x0010 + (4 * gpio));
  volatile uint32_t *a = (volatile uint32_t *)ai;
  return *a;
}

void setIOMux(unsigned gpio, uint32_t value) {
  uint32_t ai = (IOMUXBASE + 0x0010 + (4 * gpio));
  volatile uint32_t *a = (volatile uint32_t *)ai;
  *a = value;
}

void i2sUpdate() {
  uint32_t v = readReg(I2S0BASE, mI2S_RX_CONF_REG);
  v = v | 0x100;
  writeReg(I2S0BASE, mI2S_RX_CONF_REG, v);

  v = readReg(I2S1BASE, mI2S_RX_CONF_REG);
  v = v | 0x100;
  writeReg(I2S1BASE, mI2S_RX_CONF_REG, v);
}

// This function sets up the I2S clock to use the external 22MHz crystal

void setupDivider (int rate){
  writeReg(IOMUXBASE, 0, 0xFF00); // PIN_CTRL / IO_MUX_PIB_CTRL_REG p 236

  setPeripheralInput(23, 20); // I2S0_MCLK_In from GPIO20 - page 207 TRM

  writeReg(I2S0BASE, mI2S_RX_CLKM_DIV_CONF_REG,0x0); // turn off fractional (1/N+b/a) divider

  i2sUpdate();
  
  int divider;
  if (rate == 44100) divider = 2;
  else divider = 4;
  
  uint32_t v;

  v = readReg(I2S0BASE, mI2S_RX_CLKM_CONF_REG);
  v = v & 0xE7FFFFFF; // set I2S0_RX_CLK_SEL to MCLK_in
  v |= 0x18000000;
  v = v & 0xFFFFFF00; // set I2S0_RX_CLKM_DIV_NUM to 2
  v |= divider;
  writeReg(I2S0BASE, mI2S_RX_CLKM_CONF_REG, v);

  i2sUpdate();

  gpio_set_direction(20, GPIO_MODE_INPUT);

  writeReg(GPIOBASE, 0x28,
           0x100000); // GPIO_ENABLE_W1TC -clear enable on GPIO20
  writeReg(GPIOBASE, 0x554 + 4 * 20, 0x500);

  gpio_set_direction(20, GPIO_MODE_INPUT);	
}	



void audioInit(void) {

	if (!cdAudioBuffer)
		cdAudioBuffer = createSmartBuffer (50000);

  int rate = 44100;

  //  printf("About to call es8388_init\n");
  es8388_init(rate);
  //  printf("es8388_init done\n");

/*
  int initialGain = 10;
  es8388_set_adc_gain(initialGain);
  printf("Initial gain set to %d\n", initialGain);
*/ 

  /******************* This is the new v5.0 I2S system */  
  
  

/* Get the default channel configuration by helper macro.
 * This helper macro is defined in 'i2s_common.h' and shared by all the i2s communication mode.
 * It can help to specify the I2S role, and port id */
i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
/* Allocate a new tx channel and get the handle of this channel */
i2s_new_channel(&chan_cfg, &tx_handle, NULL);

/* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
 * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
 * They can help to specify the slot and clock configurations for initialization or updating */
i2s_std_config_t std_cfg = {
    .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(44100),
    .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
    .gpio_cfg = {
        .mclk = I2S_GPIO_UNUSED,
        .bclk = GPIO_NUM_38,
        .ws = GPIO_NUM_17,
        .dout = GPIO_NUM_18,
        .din = GPIO_NUM_7,
        .invert_flags = {
            .mclk_inv = false,
            .bclk_inv = false,
            .ws_inv = false,
        },
    },
};
/* Initialize the channel */
i2s_channel_init_std_mode(tx_handle, &std_cfg);

/* Before read data, start the tx channel first */
i2s_channel_enable(tx_handle);  
  
  
  
  vTaskDelay(1000 / portTICK_PERIOD_MS);

  //************************** Use external crystal

#if 1
	setupDivider (rate);
#endif

  //****************************

 #if 1 

  // Disable CLK_OUT2 from RXD pin

  gpio_set_direction(44, GPIO_MODE_INPUT);

  setPeripheralInput(
      12, 44); // RXD0 from GPIO44 - pages 207 & 230 technical reference manual

#endif

}

pthread_t audioThread;

#define AUDIOBUFFERSIZE 2048
int16_t audioBuffer[AUDIOBUFFERSIZE];
#define PI              (3.14159265)

void testWaveform (){


	int frequency = 20;		// multiple of 44100/AUDIOBUFFERSIZE (21.5Hz)
	double sin_float;
	int amplitude = 17000;
	int16_t *s = audioBuffer;	
	for (int n=0;n<AUDIOBUFFERSIZE/2;n++){
        sin_float = amplitude * sin(frequency * n * 2 * PI / (AUDIOBUFFERSIZE/2));
        int val = sin_float;
        *s++ = 0;
		*s++ = val&0xFFFF;
//		*s++ = 0;
	}
}		

void constWaveform (){

	int16_t *s = audioBuffer;	
	for (int n=0;n<AUDIOBUFFERSIZE/2;n++){
        *s++ = 0;
		*s++ = 0x4000;
//		*s++ = 0;
	}
}


//void *audioThreadCode(void *param) {
void audioThreadCode(void *param) {

	int n;
	int16_t *s = audioBuffer;
	
	testWaveform ();
//		bzero (audioBuffer,AUDIOBUFFERSIZE*2);
//	constWaveform ();

  while (true) {

    int n;
    size_t len;



	n = smartGetSamplesS (cdAudioBuffer, AUDIOBUFFERSIZE/2, audioBuffer);
	if (!n) {
//		bzero (audioBuffer,AUDIOBUFFERSIZE*2);
		testWaveform ();
	}
	

	int count = AUDIOBUFFERSIZE*2;
	s = audioBuffer;
	while (count){
		i2s_channel_write(tx_handle, s, count, &len, 100 / portTICK_PERIOD_MS);
		count -= len;
		s += len/2;
	}	


  }
}
/*
void startAudioThread() {

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, THREADSTACKSIZE);

  pthread_create(&audioThread, &attr, &audioThreadCode, 0);
}
*/

void startAudioThread() {

	xTaskCreate (&audioThreadCode, "audioThread", THREADSTACKSIZE, NULL, 7, NULL);
}


pthread_t cdThread;

int playCDSector;

void *cdThreadCode(void *param) {

	s16 *data;
	while (1){
		if (playCDEnable){
			readBlocks (playCDSector,1);
			playCDSector += BLOCKSIZE;
			data = (s16 *) getDataAddress ();
			smartPutSamplesW (cdAudioBuffer, (2352*BLOCKSIZE)/4, data);
		}
		else delay (1000);
	}	

}

void startCDThread() {

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, THREADSTACKSIZE);

  pthread_create(&cdThread, &attr, &cdThreadCode, 0);
}



void startPlayingCD (int lba){
	playCDSector = lba;
	playCDEnable = 1;	
}	

void stopPlayingCD (){
	playCDEnable = 0;
}	


